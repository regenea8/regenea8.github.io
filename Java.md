Java & Servlet & Spring

■ Java의 특징
플랫폼에 독립적인 객체지향언어. 
플랫폼에 독립적이라는 것은 리눅스 환경이나 윈도우 환경 등과 같은 개발환경에 제약을 받지 않고, 어느 플랫폼에서나 코드의 호환성과 재사용이 자유롭다는 것을 의미.

■ Overloading(메소드 중복정의) 과 Overriding(메소드 재정의) 
① Overloading : 기존 메소드의 인자를 이용하여서 하나의 함수에 여러 기능을 만드는 것. 
② Overriding : 상위 클래스에 있는 메서드와 똑같은 메서드를 하위 클래스에서 다시 만드는 행위. 즉, 하위 클래스에서 메서드를 재 정의하는 것을 말함 (다형성)

■ 객체(object) 
효율적으로 정보를 관리하기 위하여 사람들이 의미를 부여하고 분류하는 논리적인 단위이다. 
프로그래밍에서는 클래스에 정의된 내용대로 메모리에 생성된 것을 말함.

■ 클래스(Class) 
객체를 만드는 설계도(객체를 생성하는 틀의 개념)

■ 객체와 인스턴스 
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 하며, 
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함.

■ 자바언어와 기존의 언어와의 다른 특징 
- 포인터를 사용하지 않는다. (포인터는 존재, 연산을 허용하지 않음) 
- 자동으로 쓰레기 수집(garbage collection) 기능을 수행한다. 
- 엄격한 형 검사(strict type checking)를 수행하여 에러를 조기에 발견한다. 
- 실행시간에 발생하는 에러를 처리한다.

■ 예외처리의 필요성과 목적 
자바에서 프로그램의 실행하는 도중에 예외가 발생하면 발생된 그 시점에서 프로그램이 바로 종료된다. 때에 따라서는 예외가 발생 했을 때 프로그램을 종료시키는 것이 바른 판단일 수도 있다. 하지만 가벼운 예외이거나 예상을 하고 있었던 예외라면 프로그램을 종료시키는 것이 조금은 가혹(?)하다고 생각할 수 있다. 이러한 이유로 ‘예외처리’라는 수단(mechanism)이 제안되었고 예외 처리를 통해 우선 프로그램의 비정상적인 종료를 막고 발생한 예외에 대한 처리로 정상적인 프로그램을 계속 진행할 수 있도록 하는 것이 예외처리의 필요성이라 할 수 있다. 
- 예외의 발생으로 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행 상태를 유지 할 수 있도록 하는 것.

■ 객체 지향 프로그래밍(Object-Oriented Programming, OOP) 
컴퓨터 프로그래밍의 패러다임의 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음. 

- 캡슐화(Encapsulation) : 하나의 문제를 해결하기 위한 데이터와 메서드를 하나의 단위로 묶는다는 것으로서, 클래스의 내부 정의에 대해 외부에서 볼 수 없도록 하는 것이 특징(은닉화). 

- 추상화(Abstraction) : 모델(Object)의 자세한 성질을 무시하고(숨기고) 일반적인 성질을 나타낸다는 것으로서, 일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의 공통적인 성질과 행위를 일반화하여 디자인 되게 되며, 그로부터 생성된 객체는 자신의 고유의 성질을 가지게 됨. 

- 다형성(Polymorphism) : 다형성이란 같은 메시지에 대해 클래스에 따라 다른 행위를 하게 되는 특징. 일반적으로 같은 이름을 가지는 메서드에 대해 인자(Argument)의 개수와 데이터 형(Data Type)에 따라 수행되는 행위가 달라짐을 의미. 다형성을 통해서 사용자는 약속된 인터페이스를 따르는 서로 다른 객체를 같은 방식으로 사용할 수 있게 됨. 

- 상속(Inheritance) : 기존에 있던 클래스를 바탕으로(즉, 기존의 클래스로부터 상속받음) 다른 특성을 추가하여 새로운 클래스를 만들 수 있음. 

- 인스턴스(instance) : 인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿이 실제 구현된 것. (※ 템플릿 : 무엇인가를 만들 때 안내역할을 하는데 사용되는 형식(꼴), 틀 또는 모형 등을 의미)

■ 추상(abstract) 클래스 
- 추상 메소드를 하나이상 가지는 클래스. 
- new 로 객체를 생성할 수 없음. 
- 상속받은 클래스는 추상 메소드를 구현해야만 인스턴스를 생성할 수 있음. (추상클래스 끼리의 상속은 메소드 재정의가 필요없음 사용할 때 일반 클래스에서 재정의) 
- 추상 메소드란 함수의 리턴타입과 파라미터만 있고 정의부분의 없는 함수를 말함.

■ 추상화 
구체적인 개념으로부터 공통된 부분들만 추려내어 일반화 할 수 있도록 하는 것을 의미. 일반적으로 사용할 수 있는 단계가 아닌 아직 미완성적 개념.





■ 접근제어자의 종류와 특성에 대해 설명하라
public : 접근 제한이 전혀 없다.
private : 같은 클래스 내에서만 접근이 가능하다.
default : 같은 패키지 내에서만 접근이 가능하다.
protected : 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능하다.

■ 인터페이스(interface) 
- 상수 또는 추상메소드만 정의 할 수 있음. 
- 구현된 메서드는 포함 할 수가 없음. 
- 모든 변수는 static 이고 final 임. 
- 자식클래스들이 공통된 메서드를 포함하도록 하는 기능만 함. 
- 다중 상속이 가능함.
- 인터페이스란 상속관계가 없는 두 클래스간에 공통된 로직을 구현하여 사용할 수 있도록 하는 기능입니다. 클래스에 Implements 키워드를 사용하고 구현되지 않은 추상메소드와 변수를 미리 선언할 수 있습니다. 다중 상속이 가능한 것도 특징입니다.

■ 추상클래스와 인터페이스의 공통점 
- 객체를 발생시킬 수 없음. 
- 상속하여 하위 class 를 통해 객체를 발생시킴.(메소드를 재정의 해야 함)
- Abstract는 일종의 슈퍼클래스입니다. 만들고자하는 클래스의 자식들이 공통을 구현되어야하는 메소드나 변수들을 미리 선언하여 통일성을 갖게하고 추상메소드를 반드시 하나 이상 만들어야하는 특징이 있습니다. Interface와는 다르게 메소드를 구현해 놓을 수 있습니다.

■ JVM 의 구성 
- 클래스영역 : 클래스코드를 저장하는 영역. 
- 자바스택 : 메서드를 호출할 때 관련 정보를 저장하는 영역. 
- 힙(Heap) : new 라는 키워드를 통해 객체가 생성될 때 할당받는 영역. 
- 네이티브 메서드 스택
메소드영역에는 바이트코드와 전역변수가 저장이 되고, 스택영역에는 매개변수나, 임시변수, 지역변수가 저장되며, 힙영역에는 new로 만들어진 객체들이 저장됩니다.

■ Collection 에서 데이터를 저장 하는 3가지와 그 특징 
- Set : 순서가 없고, 동일한 데이터 허용이 안 됨. 
- List : 배열과 같은 구조지만, 가변적 길이를 가지고 있음(크기가 지정 되어있지 않음) 
- Map : key 값과 value 값의 형식으로 저장되면 key 값은 절대 중복이 안 됨.




■ String, StringBuffer, StringBuilder 의 차이점 
- String 클래스 : 상수문자열, 한번 생성한 후 변하지 않는 문자열 용도 
- StringBuffer 클래스 : 프로그램 내에서 계속 변하는 문자열 용도 
- StringBuilder 클래스 : StringBuilder는 Java5 에 추가된 클래스로 StringBuffer와 기능이 같다. 
- 차이점 : StringBuffer은 동기화(synchronized)되지만 StringBuilder는 그렇지 않다. 
즉, StringBuilder은 다중 thread에서는 안전하지 않으므로 동기화가 필요한 경우에는 StringBuffer를 사용하는 것이 좋다. StringBuilder -> 동기화를 하려면 synchronized 블록으로 감싸야 한다.

■ 스트림이 무엇이며 스트림의 특징은? 
- 스트림 : 데이터를 목적지로 입 • 출력하기 위한 방법. 스트림에 데이터를 쓸 수 있고, 데이터를 읽을 수 있음. 연결하고자 하는 Device 에 따라 다양한 스트림이 존재. 
- 특징 : 스트림은 FIFO 구조. 읽기, 쓰기가 동시에 되지 않음. 읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야함. 데이터가 처리되기 이전 스트림에 사용되는 스레드는 데이터가 모두 전송되기 전까지 blocking 상태에 빠짐.

■ 동기화 
- 여러 명이 접근 하는 것을 방지하기 위함. 
- 여러 명이 접근 하는 것을 막기 위해 모든 객체에 락을 포함 시키는데, 락이란 공유 객체에 여러 스레드가 동시에 접근하지 못하도록 하기 위한 것으로 모든 객체가 힙 영역에 생성될 때 자동으로 만들어 짐.

■ InnerClass 를 쓰는 이유 
내부 클래스를 사용하면 같은 패키지에 있는 다른 클래스한테 까지도 숨길 수 있기 때문에 outer class 를 통하지 않고서는 접근할 수 없음. 보안성이 좋아짐.

■ Statement 와 PreparedStatement 의 차이 
- Statement : 정적 쿼리 시 사용. 매번 파싱과정을 거쳐야 함.(부하가 생길 수 있음) SQL문 전체를 명확히 알 수 가 있어서 디버깅이 쉬움. 
- PreparedStatement : 동적 쿼리 시 사용. 한번 파싱하면 그 동일한 SQL문장을 곧바로 파싱 과정 없이 Execution 할 수 있음. (반복적인 다량의 SQL 수행 시 성능 상 이득이 있음) 오류발생 시, 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움.

■ 자바 빈즈(Beans) 란? 
자바에서 사용하는 컴포넌트. Bean은 자바에서 컴포넌트를 이용하기(?)위해 만들어 놓은 기술. 컴포넌트를 사용하면 좋은 이유는 필요 할 때마다 가져다가 사용 할 수 있다는 점인데, JSP 에서 자바의 컴포넌트를 이용해서 프로그래밍 하는 것을 빈즈 프로그래밍이라 함.



■ Connection Pool 개념 
미리 생성해 놓은 커넥션을 할당하고 반납함으로써 커넥션 생성 시간을 줄인다는 개념. 
미리 생성할 때 너무 조금 생성하면 오히려 타임오버헤드가 늘어나고, 반대로 너무 많이 생성하면 메모리 오버헤드가 늘어남.

■ Singleton 에 대해 설명 하시오 
- 프로그래밍 디자인 패턴. 
- 프로그램 상에서 두 번째 인스턴스를 만들 수 없게 하는 기능. 
- 만들어진 클래스의 객체를 단 하나만 사용하며 어디서든 그 객체를 사용할 수 있도록 만들어 줌.

■ WAS (Web Application Server)
- 서버와 클라이언트 사이에 있는 3-tier 방식으로서, Server 가 처리하는 양이 많아지면서 Server 에 생기는 부하를 해결하기 위해 개발됨. 
- Client 에서 요청이 들어오면 실제적인 처리는 WAS 가 하고 서버는 단지 Client 에 결과 값을 뿌려주는 역할만 하게 됨.
- 클라이언트는 WAS의 웹서버에 정적인 요청이 들어오면 자체적으로 클라이언트에 결과값을 전송하게 되고 동적인 요청이 들어온다면 WAS의 컨테이너에 요청을 전달하여 jsp나 Servlet구동환경에서 동적 데이터 처리 후 다시 웹서버에 전달된 결과값을 다시 클라이언트로 전달합니다.

■ 서블릿(Servlet) 
- 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램. 
- 서버용 애플릿, 웹서버에서 실행되는 작은 자바 코드. JVM 에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함. 
- 웹브라우저에서 실행되지 않고 GUI 로 구성되지 않는다는 점이 애플릿과 다름. 
- 웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용.

■ 서블릿에서 데이터를 처리 하는 방식에는 무엇이 있으며 그 특징은? 
- GET : 서버에 있는 정보를 가져오기 위해 설계 됨. 240바이트까지 전달 할 수 있음. POST 방식에 비해 속도가 빠름. URL 노출로 보안성이 요구되는 경우엔 사용 할 수 없음. 검색엔진에서 검색단어 전송에 많이 이용함. 
- POST : 서버로 정보를 올리기 위해 설계됨. 데이터크기의 제한이 없음. GET 방식에 비해 속도가 느림. URL 에 파라미터가 표시 되지 않음. 내부적으로 데이터가 이동함.






■ JSP 에서 페이지 이동 방법의 대해 설명 하시오. 
- Forward 방식 : URL 이 바뀌지 않음. 요청객체와 응답객체가 유지됨. 속도가 빠르며 요청객체에 소속 되어 있음. 
- Forward 처리 구조 
* 요청이 들어오면 Servlet 이 받음. 
* 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답. 
* 알맞은 페이지가 없다면, Forwarding 방식으로 알맞은 페이지로 넘기는데, 요청객체와 응답 객체를 포함해 넘김. 
* Url이 바뀌지 않은 상태로 응답 페이지를 통해 응답. 
- Redirect 방식 : URL 이 바뀜. 요청객체와 응답객체가 유지 되지 않음. 속도가 느리며, 응답객체에 소속 되어 있음. 
- Redirect 처리 구조 
* 요청이 들어오면 Servlet 이 받음. 
* 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답. 
* 알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청을 하게끔 응답을 보냄. 
* 클라이언트는 응답을 받고, 다시 그 요청의 맞는 URL 로 요청함.

■ Cookie 와 Session 의 차이 
- Cookie : 클라이언트에 정보를 저장하기 때문에 서버에 부하가 없음. 사라지는 때(시간)를 지정 할 수가 있음. 
- Session : 서버에 정보를 저장하기 때문에 서버에 부하가 많이 생김. 해당 클라이언트와 일정시간동안 작용이 없으면 서버메모리에서 해제 됨. 직접적으로 해제 시킬 수 있는 method 가 있음.

■ 세션과 쿠키를 사용하는 이유는 무엇일까요?
HTTP 프로토콜은 연결지향적인 성격이 없기때문에 사용자의 방문형태를 저장할 방법이 없습니다. 그렇기때문에 세션과 쿠키를 이용해서 사용자의 정보를 저장하여 방문상태를 와 정보를 유지하기 위해 사용합니다.

■ 서블릿 라이프 사이클(생명 주기) 
- Servlet 은 javax.servlet.GenericServlet 클래스나 javax.servlet.HttpServlet 클래스를 상속받아서 작성하며, init(), service(), destory() 의 세 개의 메서드에 의한 생명주기를 갖는다. 서블릿이 로딩될 때 단 한번 init() 메서드를 호출하게 되며 클라이언트의 요청이 있을 때마다 service() 메서드를 반복적으로 호출하게 된다. 서블릿 객체는 메모리를 해제하기 위해서 destroy() 메서드를 호출하게 된다.
 

■ 서블릿의 실행 과정 
- 서버가 클라이언트의 연결 요청을 받음. 
- 웹 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 연결 응답 정보를 담고있는 Response 객체를 생성. 
- 접수된 URL 을 분석 후 해당 서블릿 객체를 생성하고, 사용자의 요청을 처리하기 위해 스레드를 생성 후 service() 메소드에 인자값을 담아 호출. 
- service() 메소드는 Request 객체를 참고하여 어떤 연결 요청 방식(GET 방식인지 POST 방식인지)으로 들어왔는지 파악 함. 
- 들어온 요청 방식에 따라 get 방식은 doGet() 메소드를 post 방식은 doPost() 메소드를 호출하여 처리 함. 
- service() 메소드의 인자값으로 넘겨받은 response 객체를 이용하여 클라이언트에게 결과를 보여줌. 
- 사용자 요청을 처리하기 위해 생성한 스레드를 소멸

■ JSP 라이프 사이클(생명 주기) 
- JSP 변환 서블릿 프로그램은 _jspInit(), _jspService(), _jspDestroy() 의 세 가지 메서드에 의해서 초기화, 서비스, 파괴의 과정을 거친다. _jspInit() 메서드는 단 한번 호출하며 _jspService() 메서드는 서비스 요청이 있을 때마다 호출하게 된다. 즉, 클라이언트에서 JSP 문서를 클릭하게 되면 JSP 문서는 Servlet 으로 변환되고, 그 변환된 Servlet 에서 처음으로 _jspInit() 메서드가 호출된다. _jspInit() 메서드는 JSP 에서 변환된 Servlet 의 초기화 및 서비스를 시작하기 위한 준비를 하는 메서드이다. 그리고 서블릿에서 init() 메서드가 service() 메서드를 호출하듯이 JSP의 _jspInit() 메서드는 _jspService() 메서드를 호출한다. 호출된 _jspService() 메서드는 클라이언트에서 요구한 작업을 수행하는 메서드이다.

■ JSP 는 무엇이며 JSP 의 특징은 무엇인가? 
- JSP 란? : Java Servet Pages 의 약자로써 자바를 기반으로 하고 있는 스크립트 언어. 
- 특징 : 자바언어를 기반으로하는 스크립트 언어로써 자바의 장점을 사용 할 수 있음. 자바언어를 기반으로 하고 있기 때문에 플랫폼에 상관없이 사용할 수 있음. 표현언어, 표현식, 스크립트릿 등의 다양한 스크립트 요소와 액션 태그 등을 제공함으로써 보다 쉽게 웹 어플리케이션을 개발 할 수 있음. 서블릿/EJB 등의 엔터프라이즈 기술들과 잘 융합됨.

■ Framework 
- 특정 형태의 소프트웨어 문제를 해결하기 위해, 상호 협력하는 클래스들과 인터페이스의 집합.
- 장점 : 재사용성, 단순성, 역할구분, 확장성, 유지보수용이. 
- 프레임웍과 라이브러리 차이 라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음. 프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공. 

■ MVC 패턴이란 ? 
- Model, View, Control의 역할을 확실하게 분리시켜놓는 프로그래밍 기법. MVC 란 중간에 Controller 컴포넌트를 두어 비즈니스 로직과 데이터 접근 로직, 프리젠테이션 로직을 분리시킨 디자인 패턴이다. 각 영역별로 역할이 명확히 구분되므로 모듈 간의 의존성을 낮추어 재사용성 및 확장이 용이한 구조이기 때문에 유지보수에 유리하다. 모델 1이 JSP 에 프리젠테이션 로직과 비즈니스 로직, 데이터 접근 로직이 함께 들어갔던 반면 모델 2는 각각의 역할을 나누어 작업을 분담시킨 MVC 패턴을 웹에 적용한 것이다. View 를 담당하는 JSP는 프리젠테이션 로직만을 처리하고 Controller 는 요청을 어디로 보낼지 결정한다. 그리고 Model 은 비지니스 레이어에 포함된다. 

■ Model 1 방식 과 Model 2 방식의 특징과 차이점 
1) Model 1 디자인 코드와 자바 코드(비즈니스로직)를 구분하지 않고, 하나의 JSP 파일 내에 기술해서 웹 프로그램을 제작 하는 방식. 
- Model 1 특징 
* 개발하기가 쉽고, 배우기가 쉬움. 
* 디자인코드와 비즈니스로직의 구분이 명확하지 않아, 복잡도가 높음. 
* 수정 시 디자이너와 개발자의 협업이 필요. 
* 비즈니스로직의 재 사용성이 어려우며, 유지 보수가 힘듬. 
2) Model 2 웹 어플리케이션을 개발할 때, MVC패턴을 적용하여, 웹 어플리케이션의 개발이 가능하도록 구현한 것. 
- Model 2 특징 
* 초기 설계에 많은 시간이 소요. 
* 디자인코드와 비즈니스로직이 분리되며, 비즈니스로직의 재사용성이 높아짐. 
* 비즈니스로직 계층의 확장성이 용이하며, 유지보수가 편하다.
 
■ Spring 
Java Enterprise Application 개발에 사용 되는 Application Framework. 개발을 빠르고 효율적으로 할 수 있도록 Application의 바탕이 되는 틀과 공통프로그래밍 모델, 기술 API를 제공. 
- 특징 : 스프링은 종속객체주입이라는 기술을 통해 낮은 결합도를 유지할 수 있음. AOP 를 이용하여 객체지향만이 아닌 관심지향 기법을 활용. EJB 기능을 대체 할 수 있음. 트랜젝션 처리를 위한 일관된 방법을 제공. 레이어간 연결이 interface 로 이루어지기 때문에 interface 생성이 필요. 다양한 프레임워크와의 통합. 
-  MVC 모델에서 커버하는 부분 : Controller 지원. 
- 실행 순서(실행구조) 
web.xml 의 등록된 DispatcherServlet 을 통해서 요청에 대해 진입.
DispatcherServlet 은 Client 로부터 들어온 URL 을 HandlerMapping 라는 곳으로 전송 후 URL을 분석해서 알맞은 Controller 이름을 다시 DispatcherServlet 으로 보냄. 
HandlerMapping 이라는 것을 통해서 실행될 Controller의 이름을 입력받은 DispatcherServlet 은 전달받은 Controller 를 실행시킴. 이렇게 실행된 Controller 는 스프링에서 제공하는 ModelAndView 객체에 뷰 페이지에 전달할 객체와 View Page 이름 정보를 담고 DispatcherServlet 으로 보냄. 
ViewResolver 를 통해 보여 질 View 페이지를 탐색한 후 View 페이지를 보여줌.

■ DI 와 AOP 의 대해 설명하시오. 
- DI : Dependency Injection 의 약자. 
의존성 주입이란 뜻. 스프링을 적용하여 applicationContext.xml 에서 설정만 해주면, 외부 설정파일(xml)에서 연관관계에 있는 객체를 주입해주기 때문에 의존객체를 찾기 위한 코드가 필요하지 않게 됨. 즉, 외부설정에서 객체를 찾아서 쓰기 때문에 코드 내에 의존관계를 맺는 코드 생성이 불필요. 
- AOP : Aspect oriented programming 의 약자. 관심지향 프로그래밍. 프로그래밍을 할 때 특정한 관심사를 가진 코드 부분을 별도의 모듈로 분리함으로써, 기존 객체지향의 강력한 기능(상속, 위임)만으로는 처치가 곤란했던 중복을 제거할 수 있게 됨

■ AJAX(Asynchronous JavaScript and XML)
AJAX 는 비동기식으로 Javascript 를 이용해 클라이언트 측에서 페이지 리로딩 없이 필요한 데이터를 얻어내는 기법을 말한다. 페이지 이동 없이 화면을 전환할 수 있으며 서버 처리를 기다리지 않고 비동기 요청이 가능하다. 수신하는 데이터량을 줄일 수 있고, 클라이언트에게 처리를 위임할 수도 있다는 장점이 있다. 
- 특징 : 필요한 데이터만 서버로 보내고 해당 정보만 받음. 서버로부터 정보를 받을때는 xml 이나 json 형태로 받고 클라이언트에서는 그 정보들을 DOM을 통해 화면을 재가공 하여 보여주기 때문에, 서버와 교환되는 데이터의 양이 적어지므로 점유율을 낮출 수 있음. 클라이언트에서 데이터를 처리하므로 서버에 부담이 덜 가기 때문에 다른 응답요청에 신속히 응대 할 수 있음.
 
■ 쓰레드를 구현하기 위한 인터페이스, 클래스는?
쓰레드를 구현하는 방법은 Thread클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법, 2가지가 있다. Thread클래스를 상속받으면 다른 클래스를 상속받을 수 없기 때문에, Runnable인터페이스를 구현하는 방법이 일반적이다.

■ Static 키워드에 대해 설명하세요.
Static이 붙은 멤버변수와 메서드, 그리고 초기화 블록은 인스턴스가 아닌 클래스에 관계 된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.

■ 해시테이블에 대해 설명해주세요
중복되지 않은 키와 그 키와 연결된 값이 쌍으로 묶여 있는 자료구조입니다. 
HashMap과 사용법은 비슷하지만 동기화기능이 제공이되는것은 HashTable입니다. 
동기화가 필요하다면 hashtable을 쓰고 필요하지 않다면 Hashmap을 쓰는것이 좋습니다.

■ JVM과 JRE, JDK 를 설명해주세요.
JVM은 자바 버추얼 머신의 약자로 자바 소스로부터 만들어지는 자바 바이너리 파일을 실행할 수 있습니다. 바이너리 코드를 읽어 검증, 실행합니다.
JRE는 자바프로그램을 동작시킬때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있습니다.
JDK는 개발을하기 위해 필요한 도구들을 포함합니다.

■ 자바코드의 실행과정
코드를 javac컴파일러를 통해 컴파일하게 되면 바이트 코드의 파일이 생성이 되는데 
이것을 자바런처가 jvm에게 바이트 코드를 전달하여 검증 및 확인작업을 걸쳐 작성한 코드가 실행되게 됩니다.

■ POJO
Plain Old Java Object, 간단히 POJO는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다.
개념적으로는 자바 언어 명세에서 강제적으로 제한되어진 것(extends, implements, Annotation)을 제외하고 어떠한 제약이 없는 자바 객체를 말한다. 
 
■ @Resource @Autowired @Inject 
- 공통점은 의존 주입 이다.
@Inject와 @Resource는 JSR에 실려있는 자바 기존의 어노테이션입니다. 반면 @Autowired의 경우에는 스프링에서 등장한 어노테이션입니다. 따라서 스프링 이외에서는 사용 할 수 없습니다. 만약에 프로젝트를 스프링에서 다른 프레임워크로 바꿀 생각이 있으시다면 @Autowired보단 @Inject나 @Resource를 쓰시면 됩니다.
또한 연결 방식은 @Autowired와 @Inject는 우선 순위가 타입에 맞춰서 하는 반면, @Resource는 이름에 맞춰서 연결하게 됩니다.

■ call by value. call by reference
예를들어 Java에서 foo라는 함수의 매개변수로 프리미티브 타입 a라는 값을 변경하게 된다면 이것은 콜바이 벨류가 일어나게 되는데 a라는 값을 변경하려 해도 새로운 메모리공간에 할당하여 변경하기 때문에 원래의 값에 변경은 일어나지 않습니다.
그런데 매개변수로 레퍼런스타입의 a가 들어오게 된다면 콜바이 레퍼런스가 일어나 주소값에 대해서 연산이 들어가기 때문에 새로운 메로리공간의 할당없이 원하고자 하는 값을 변경할 수 있습니다.


 
DB

■ TRIGGER 
트리거란 DML 작업 즉, insert, delete, update 작업이 일어날 때 자동으로 실행되는 객체로 특히 이런 트리거를 DML 트리거라 한다. 트리거는 데이터의 무결성 뿐만 아니라 자동으로 파생된 열 값 생성, 잘못된 트랜잭션 방지, 복잡한 보안 권한 강제 수행 등을 처리 한다.

■ PROCEDURE 
PL/SQL에서 가장 대표적인 구조인 스토어드 프로시저는 개발자가 자주 실행해야 하는 업무 흐름을 미리 작성하여 데이터베이스 내에 저장해 두었다가 필요할 때마다 호출하여 실행할 수 있다. 

■ CURSOR 
오라클에서는 하나의 레코드가 아닌 여러 레코드로 구성된 작업영역에서 SQL문을 실행하고 그 과정에 생긴 정보를 저장하기 위해서 CURSOR를 사용하며, 커서에는 암시적 커서와 명시적 커서가 있다. 암시적 커서는 모든 SQL 문에 기본적으로 존재하며, SQL 문 실행 후 오직 하나의 row만 출력하게 된다. 그러나 SQL 문 실행한 결과물(result set)이 여러 row 로 된 경우 CURSOR 를 명시적으로 선언하여야 여러 row 를 다룰 수 있다. 또한 커서는 Private SQL의 작업영역으로 오라클 서버에 의해 실행되는 모든 SQL문은 연관된 각각의 커서를 소유하고 있다. 9. 

■ Index 
① 인덱스를 사용하는 이유 
- 인덱스를 만드는 이유는 가장 큰 이유가 데이터를 빠르게 검색하기 위함이다. 
- 인덱스를 만드는 두번째 이유는 Row의 유일성을 유지하기 위한 것이다 
② 인덱스 사용 시 단점 
- 인덱스를 만들게 되면 그 정보를 유지하기 위해서 디스크 공간도 필요하게 되고, 인덱스가 걸려 있는 테이블은 인덱스가 없을 때보다 데이터를 추가하거나 변경할 때 많은 시간이 소요된다. 
③ 인덱스의 종류 
- Unique Clustered Index 
- Nonunique Clustered Index 
- Unique Nonclustered Index 
- Nonunique Nonclustered Index 
④ 클러스터드 인덱스는 
- 한 테이블에 단 한개만 존재할 수 있다. 
- 범위(Range)를 주어 검색 할 때 탁원한 기능을 발휘한다. 
예) 키순으로 서세요, 나이순으로 서세요. 이름순으로 서세요 
⑤ 넌클러스터드 인덱스(Nonclustered Index)는 
- 한 테이블에 여러개 존재할 수 있다. 
- 특정한 값으로 찾아갈 때(Seek) 탁월한 성능을 발휘한다. 예) 도서명, 저자명, 분야명
 
■ 트랜잭션, 롤백, 커밋 
① 트랜잭션 : 일련의 작업단위로 특성으로 ACID(원자성,일관성,고립성,영구성)가 있음. 
② 트랜잭션의 필요성 : 여러작업이 한 자원에 동시에 변경, 참조가 필요한 경우, 작업공정이 긴 경우. 
③ 트랜잭션의 시작 
- 첫 DML(데이터 조작어)구문이 실행될 때.(SELECT에선 제외) 
- 사용자가 SAVEPOINT를 설정할 때. 
④ 트랜잭션의 종료 
- commit 수행. ☞ rollback 수행. 
- DDL(데이터 정의어), DCL(데이터 제어어)이 실행될 때. 
- 오라클 내부에서 자동 commit 수정. 
- 사용자가 sqlplus를 종료할 때, 시스템 크래쉬 발생. 
⑤ 커밋과 롤백 전 
- 롤백으로 데이터 회복가능. 
- 현재 유저는 자신이 바꾼 데이터를 확인할 수 있다. 
- 다른 유저에게는 바뀐 데이터 내용이 반영되지 않음. 
- 영향을 받은 레코드는 잠금 상태. 
⑥ 커밋 후 
- 데이터는 영구적으로 변경. 
- 복구 불가능. 
- 모든 유저에게 변경 내용이 반영. 
- 해당 레코드의 잠금 해제, 다른 유저들이 다룰 수 있음. 
- 세이브 포인트가 삭제. 
⑦ 롤백 후 
- 데이터의 변경이 취소. 
- 데이터의 이전 상태가 회복. 
- 데이터에 대한 잠금이 해제.

■ DB 정규화의 목적 
자료정규화 작업의 가장 큰 목적은 자료저장의 중복성 배제이다. 정규화이론에서는 릴레이션의 형태가 여러단계로 구분되며, 가장 기본적인 정규화조건도 만족하지 못하는 릴레이션을 비정규형, 만족하는 릴레이션을 제1정규형이라고 부름. 조건이 점점 엄격해짐에 따라 제2, 제3, 제4, 제5정규형으로 구분됨. 높은 단계의 정규형으로 나아갈수록 데이터의 본질적 의미가 릴레이션 구조에 보다 정확히 반영되고, 데이터 중복을 줄이고, 데이터 변경 시 발생하는 문제점을 방지하고, 궁극적으로 데이터 무결성(data integrity)을 재고할 수 있다고 가정함.
 
통신

■ TCP와 UDP의 차이점이라 한다면 무엇일까요
TCP(Transmission Control Protocol)
TCP는 안전하고 확실하게 데이터를 전달하는 프로토콜로 전송도중 실패했을때를 대비해 재전송하는 기능이 있습니다. 그렇기때문에 정확성이 요구되는 이메일이나 WWW서비스에서 주로 사용됩니다.
UDP는 데이터를 빨리 전달하는 것을 목적으로 하는 프로토콜로 데이터를 보내기만할 뿐 특별한만한 것은 없습니다. 주로 사용되는 곳은 실시간성이 중요한 IP전화나 스트리밍 송출등에서 사용됩니다.

■ TCP/.IP, HTTP
tcp/ip 는 transport 계층에서 동작한다. 
http는 application 계층에서 동작 한다. 이 계층에서 동작하는 프로토콜은 http 말고도 smtp, IMAP 등이 있다
① 데이터 형태
tcp : byte array(binary)로 정보를 통신
http: String으로 정보를 통신
② 연결방식
tcp : 언제나 서버와 연결돼있어야하며, request 없이도 recevie가 일어남.
http: keep-alive로 지속적인 연결은 가능합니다만, 기본적으론 close로 돼 있으며, request를 하여야만 recevie가 일어남
③ 속도 
tcp / IP 기반 소켓을 쓰는 것이 빠르다. 바인딩 과정 HTTP 변환 과정등이 생략되기 때문임.
연결지향 / 동기식 통신이 필요하다면 소켓 통신을 이용해야 한다.
